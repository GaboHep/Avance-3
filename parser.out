Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    IMPORT
    MAIN
    NEW
    PACKAGE
    PERIOD
    PI
    POW
    PRINT
    PRINTF
    WHILE
    XCENTAGE

Grammar

Rule 0     S' -> program
Rule 1     program -> repeatLines
Rule 2     value -> INT
Rule 3     value -> FLOAT
Rule 4     value -> STR
Rule 5     value -> ID
Rule 6     repeatLines -> line
Rule 7     repeatLines -> line repeatLines
Rule 8     line -> ID EQUALSVAR value
Rule 9     line -> stamentFor
Rule 10    line -> consulta
Rule 11    line -> push
Rule 12    line -> funcion
Rule 13    line -> array
Rule 14    line -> slice
Rule 15    line -> mathExpProd
Rule 16    line -> CASE INT TWODOTS line
Rule 17    line -> switch
Rule 18    line -> pila
Rule 19    line -> func_declaration
Rule 20    line -> ID EQUALSVAR INT
Rule 21    line -> retorno
Rule 22    line -> declaration
Rule 23    retorno -> ID
Rule 24    retorno -> ID COMMA
Rule 25    retorno -> RETURN retorno
Rule 26    expression -> ID comparator ID
Rule 27    expression -> ID comparator INT
Rule 28    expression -> ID
Rule 29    comparator -> COMPARE
Rule 30    comparator -> MORETHAN
Rule 31    comparator -> MINUSTHAN
Rule 32    operator -> DIVIDE
Rule 33    operator -> MINUS
Rule 34    operator -> PLUS
Rule 35    operator -> TIMES
Rule 36    stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
Rule 37    switch -> SWITCH ID LCURLY repeatLines RCURLY
Rule 38    consulta -> IF expression LCURLY statements RCURLY
Rule 39    consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
Rule 40    statements -> statement
Rule 41    statements -> statement COMMA statements
Rule 42    statement -> ID
Rule 43    number -> INT
Rule 44    number -> FLOAT
Rule 45    array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
Rule 46    elemArray -> number
Rule 47    elemArray -> number COMMA elemArray
Rule 48    slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
Rule 49    elemSlice -> number
Rule 50    elemSlice -> number COMMA elemSlice
Rule 51    pila -> TYPE STACK LBRACKETS RBRACKETS ID
Rule 52    pila -> TYPE STACK INTERFACE LCURLY RCURLY
Rule 53    pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
Rule 54    push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
Rule 55    funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
Rule 56    func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
Rule 57    return_types -> ID COMMA ID
Rule 58    return_types -> ID
Rule 59    funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
Rule 60    param_list -> param
Rule 61    param_list -> param_list COMMA param
Rule 62    param -> value ID
Rule 63    declaration -> VAR ID ID
Rule 64    declaration -> VAR ID ID EQUALSVAR number
Rule 65    declaration -> VAR ID ID EQUALSVAR STR
Rule 66    mathExp -> number
Rule 67    mathExp -> number operator number
Rule 68    mathExpProd -> mathExp
Rule 69    mathExpProd -> mathExp operator mathExpProd

Terminals, with rules where they appear

APPEND               : 54
CASE                 : 16
COMMA                : 24 41 47 50 54 54 57 61
COMPARE              : 29
DIVIDE               : 32
DOTCOMA              : 36 36
ELSE                 : 39
EQUALS               : 36
EQUALSVAR            : 8 20 45 48 64 65
FLOAT                : 3 44
FOR                  : 36
FUNC                 : 54 55 56 59
ID                   : 5 8 20 23 24 26 26 27 28 36 36 36 36 37 42 45 45 48 48 51 53 54 54 54 54 54 55 55 56 57 57 58 59 59 59 62 63 63 64 64 65 65
IF                   : 38 39
IMPORT               : 
INT                  : 2 16 20 27 36 43 45
INTERFACE            : 52
LBRACKETS            : 45 48 51 53
LCURLY               : 36 37 38 39 39 45 48 52 53 54 55 56 59
LEN                  : 36
LPAREN               : 36 54 54 55 56 56 59
MAIN                 : 
MINUS                : 33
MINUSTHAN            : 31 36
MORETHAN             : 30
NEW                  : 
PACKAGE              : 
PERIOD               : 
PI                   : 
PLUS                 : 34 36 36
POW                  : 
PRINT                : 
PRINTF               : 
PUSH                 : 54
RBRACKETS            : 45 48 51 53
RCURLY               : 36 37 38 39 39 45 48 52 53 54 55 56 59
RETURN               : 25 54 55 59
RPAREN               : 36 54 54 55 56 56 59
STACK                : 51 52 53 54 54
STR                  : 4 65
STRUCT               : 53
SWITCH               : 37
TIMES                : 35
TWODOTS              : 16
TYPE                 : 51 52 53
VAR                  : 63 64 65
WHILE                : 
XCENTAGE             : 
error                : 

Nonterminals, with rules where they appear

array                : 13
comparator           : 26 27
consulta             : 10
declaration          : 22
elemArray            : 45 47
elemSlice            : 48 50
expression           : 38 39
func_declaration     : 19
funcion              : 12
line                 : 6 7 16
mathExp              : 68 69
mathExpProd          : 15 69
number               : 46 47 49 50 64 66 67 67
operator             : 67 69
param                : 60 61
param_list           : 59 61
pila                 : 18
program              : 0
push                 : 11
repeatLines          : 1 7 36 37 55 56 59
retorno              : 21 25
return_types         : 56
slice                : 14
stamentFor           : 9
statement            : 40 41
statements           : 38 39 39 41
switch               : 17
value                : 8 53 55 62

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . repeatLines
    (6) repeatLines -> . line
    (7) repeatLines -> . line repeatLines
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    program                        shift and go to state 1
    repeatLines                    shift and go to state 2
    line                           shift and go to state 3
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 1

    (0) S' -> program .



state 2

    (1) program -> repeatLines .

    $end            reduce using rule 1 (program -> repeatLines .)


state 3

    (6) repeatLines -> line .
    (7) repeatLines -> line . repeatLines
    (6) repeatLines -> . line
    (7) repeatLines -> . line repeatLines
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

  ! shift/reduce conflict for RETURN resolved as shift
    $end            reduce using rule 6 (repeatLines -> line .)
    RCURLY          reduce using rule 6 (repeatLines -> line .)
    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

  ! RETURN          [ reduce using rule 6 (repeatLines -> line .) ]

    line                           shift and go to state 3
    repeatLines                    shift and go to state 29
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 4

    (8) line -> ID . EQUALSVAR value
    (20) line -> ID . EQUALSVAR INT
    (45) array -> ID . EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> ID . EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (23) retorno -> ID .
    (24) retorno -> ID . COMMA

    EQUALSVAR       shift and go to state 30
    ID              reduce using rule 23 (retorno -> ID .)
    CASE            reduce using rule 23 (retorno -> ID .)
    FOR             reduce using rule 23 (retorno -> ID .)
    IF              reduce using rule 23 (retorno -> ID .)
    FUNC            reduce using rule 23 (retorno -> ID .)
    SWITCH          reduce using rule 23 (retorno -> ID .)
    TYPE            reduce using rule 23 (retorno -> ID .)
    RETURN          reduce using rule 23 (retorno -> ID .)
    VAR             reduce using rule 23 (retorno -> ID .)
    INT             reduce using rule 23 (retorno -> ID .)
    FLOAT           reduce using rule 23 (retorno -> ID .)
    $end            reduce using rule 23 (retorno -> ID .)
    RCURLY          reduce using rule 23 (retorno -> ID .)
    COMMA           shift and go to state 31


state 5

    (9) line -> stamentFor .

    ID              reduce using rule 9 (line -> stamentFor .)
    CASE            reduce using rule 9 (line -> stamentFor .)
    FOR             reduce using rule 9 (line -> stamentFor .)
    IF              reduce using rule 9 (line -> stamentFor .)
    FUNC            reduce using rule 9 (line -> stamentFor .)
    SWITCH          reduce using rule 9 (line -> stamentFor .)
    TYPE            reduce using rule 9 (line -> stamentFor .)
    RETURN          reduce using rule 9 (line -> stamentFor .)
    VAR             reduce using rule 9 (line -> stamentFor .)
    INT             reduce using rule 9 (line -> stamentFor .)
    FLOAT           reduce using rule 9 (line -> stamentFor .)
    $end            reduce using rule 9 (line -> stamentFor .)
    RCURLY          reduce using rule 9 (line -> stamentFor .)


state 6

    (10) line -> consulta .

    ID              reduce using rule 10 (line -> consulta .)
    CASE            reduce using rule 10 (line -> consulta .)
    FOR             reduce using rule 10 (line -> consulta .)
    IF              reduce using rule 10 (line -> consulta .)
    FUNC            reduce using rule 10 (line -> consulta .)
    SWITCH          reduce using rule 10 (line -> consulta .)
    TYPE            reduce using rule 10 (line -> consulta .)
    RETURN          reduce using rule 10 (line -> consulta .)
    VAR             reduce using rule 10 (line -> consulta .)
    INT             reduce using rule 10 (line -> consulta .)
    FLOAT           reduce using rule 10 (line -> consulta .)
    $end            reduce using rule 10 (line -> consulta .)
    RCURLY          reduce using rule 10 (line -> consulta .)


state 7

    (11) line -> push .

    ID              reduce using rule 11 (line -> push .)
    CASE            reduce using rule 11 (line -> push .)
    FOR             reduce using rule 11 (line -> push .)
    IF              reduce using rule 11 (line -> push .)
    FUNC            reduce using rule 11 (line -> push .)
    SWITCH          reduce using rule 11 (line -> push .)
    TYPE            reduce using rule 11 (line -> push .)
    RETURN          reduce using rule 11 (line -> push .)
    VAR             reduce using rule 11 (line -> push .)
    INT             reduce using rule 11 (line -> push .)
    FLOAT           reduce using rule 11 (line -> push .)
    $end            reduce using rule 11 (line -> push .)
    RCURLY          reduce using rule 11 (line -> push .)


state 8

    (12) line -> funcion .

    ID              reduce using rule 12 (line -> funcion .)
    CASE            reduce using rule 12 (line -> funcion .)
    FOR             reduce using rule 12 (line -> funcion .)
    IF              reduce using rule 12 (line -> funcion .)
    FUNC            reduce using rule 12 (line -> funcion .)
    SWITCH          reduce using rule 12 (line -> funcion .)
    TYPE            reduce using rule 12 (line -> funcion .)
    RETURN          reduce using rule 12 (line -> funcion .)
    VAR             reduce using rule 12 (line -> funcion .)
    INT             reduce using rule 12 (line -> funcion .)
    FLOAT           reduce using rule 12 (line -> funcion .)
    $end            reduce using rule 12 (line -> funcion .)
    RCURLY          reduce using rule 12 (line -> funcion .)


state 9

    (13) line -> array .

    ID              reduce using rule 13 (line -> array .)
    CASE            reduce using rule 13 (line -> array .)
    FOR             reduce using rule 13 (line -> array .)
    IF              reduce using rule 13 (line -> array .)
    FUNC            reduce using rule 13 (line -> array .)
    SWITCH          reduce using rule 13 (line -> array .)
    TYPE            reduce using rule 13 (line -> array .)
    RETURN          reduce using rule 13 (line -> array .)
    VAR             reduce using rule 13 (line -> array .)
    INT             reduce using rule 13 (line -> array .)
    FLOAT           reduce using rule 13 (line -> array .)
    $end            reduce using rule 13 (line -> array .)
    RCURLY          reduce using rule 13 (line -> array .)


state 10

    (14) line -> slice .

    ID              reduce using rule 14 (line -> slice .)
    CASE            reduce using rule 14 (line -> slice .)
    FOR             reduce using rule 14 (line -> slice .)
    IF              reduce using rule 14 (line -> slice .)
    FUNC            reduce using rule 14 (line -> slice .)
    SWITCH          reduce using rule 14 (line -> slice .)
    TYPE            reduce using rule 14 (line -> slice .)
    RETURN          reduce using rule 14 (line -> slice .)
    VAR             reduce using rule 14 (line -> slice .)
    INT             reduce using rule 14 (line -> slice .)
    FLOAT           reduce using rule 14 (line -> slice .)
    $end            reduce using rule 14 (line -> slice .)
    RCURLY          reduce using rule 14 (line -> slice .)


state 11

    (15) line -> mathExpProd .

    ID              reduce using rule 15 (line -> mathExpProd .)
    CASE            reduce using rule 15 (line -> mathExpProd .)
    FOR             reduce using rule 15 (line -> mathExpProd .)
    IF              reduce using rule 15 (line -> mathExpProd .)
    FUNC            reduce using rule 15 (line -> mathExpProd .)
    SWITCH          reduce using rule 15 (line -> mathExpProd .)
    TYPE            reduce using rule 15 (line -> mathExpProd .)
    RETURN          reduce using rule 15 (line -> mathExpProd .)
    VAR             reduce using rule 15 (line -> mathExpProd .)
    INT             reduce using rule 15 (line -> mathExpProd .)
    FLOAT           reduce using rule 15 (line -> mathExpProd .)
    $end            reduce using rule 15 (line -> mathExpProd .)
    RCURLY          reduce using rule 15 (line -> mathExpProd .)


state 12

    (16) line -> CASE . INT TWODOTS line

    INT             shift and go to state 32


state 13

    (43) number -> INT .

    DIVIDE          reduce using rule 43 (number -> INT .)
    MINUS           reduce using rule 43 (number -> INT .)
    PLUS            reduce using rule 43 (number -> INT .)
    TIMES           reduce using rule 43 (number -> INT .)
    ID              reduce using rule 43 (number -> INT .)
    CASE            reduce using rule 43 (number -> INT .)
    FOR             reduce using rule 43 (number -> INT .)
    IF              reduce using rule 43 (number -> INT .)
    FUNC            reduce using rule 43 (number -> INT .)
    SWITCH          reduce using rule 43 (number -> INT .)
    TYPE            reduce using rule 43 (number -> INT .)
    RETURN          reduce using rule 43 (number -> INT .)
    VAR             reduce using rule 43 (number -> INT .)
    INT             reduce using rule 43 (number -> INT .)
    FLOAT           reduce using rule 43 (number -> INT .)
    $end            reduce using rule 43 (number -> INT .)
    RCURLY          reduce using rule 43 (number -> INT .)
    COMMA           reduce using rule 43 (number -> INT .)


state 14

    (17) line -> switch .

    ID              reduce using rule 17 (line -> switch .)
    CASE            reduce using rule 17 (line -> switch .)
    FOR             reduce using rule 17 (line -> switch .)
    IF              reduce using rule 17 (line -> switch .)
    FUNC            reduce using rule 17 (line -> switch .)
    SWITCH          reduce using rule 17 (line -> switch .)
    TYPE            reduce using rule 17 (line -> switch .)
    RETURN          reduce using rule 17 (line -> switch .)
    VAR             reduce using rule 17 (line -> switch .)
    INT             reduce using rule 17 (line -> switch .)
    FLOAT           reduce using rule 17 (line -> switch .)
    $end            reduce using rule 17 (line -> switch .)
    RCURLY          reduce using rule 17 (line -> switch .)


state 15

    (18) line -> pila .

    ID              reduce using rule 18 (line -> pila .)
    CASE            reduce using rule 18 (line -> pila .)
    FOR             reduce using rule 18 (line -> pila .)
    IF              reduce using rule 18 (line -> pila .)
    FUNC            reduce using rule 18 (line -> pila .)
    SWITCH          reduce using rule 18 (line -> pila .)
    TYPE            reduce using rule 18 (line -> pila .)
    RETURN          reduce using rule 18 (line -> pila .)
    VAR             reduce using rule 18 (line -> pila .)
    INT             reduce using rule 18 (line -> pila .)
    FLOAT           reduce using rule 18 (line -> pila .)
    $end            reduce using rule 18 (line -> pila .)
    RCURLY          reduce using rule 18 (line -> pila .)


state 16

    (19) line -> func_declaration .

    ID              reduce using rule 19 (line -> func_declaration .)
    CASE            reduce using rule 19 (line -> func_declaration .)
    FOR             reduce using rule 19 (line -> func_declaration .)
    IF              reduce using rule 19 (line -> func_declaration .)
    FUNC            reduce using rule 19 (line -> func_declaration .)
    SWITCH          reduce using rule 19 (line -> func_declaration .)
    TYPE            reduce using rule 19 (line -> func_declaration .)
    RETURN          reduce using rule 19 (line -> func_declaration .)
    VAR             reduce using rule 19 (line -> func_declaration .)
    INT             reduce using rule 19 (line -> func_declaration .)
    FLOAT           reduce using rule 19 (line -> func_declaration .)
    $end            reduce using rule 19 (line -> func_declaration .)
    RCURLY          reduce using rule 19 (line -> func_declaration .)


state 17

    (21) line -> retorno .

    ID              reduce using rule 21 (line -> retorno .)
    CASE            reduce using rule 21 (line -> retorno .)
    FOR             reduce using rule 21 (line -> retorno .)
    IF              reduce using rule 21 (line -> retorno .)
    FUNC            reduce using rule 21 (line -> retorno .)
    SWITCH          reduce using rule 21 (line -> retorno .)
    TYPE            reduce using rule 21 (line -> retorno .)
    RETURN          reduce using rule 21 (line -> retorno .)
    VAR             reduce using rule 21 (line -> retorno .)
    INT             reduce using rule 21 (line -> retorno .)
    FLOAT           reduce using rule 21 (line -> retorno .)
    $end            reduce using rule 21 (line -> retorno .)
    RCURLY          reduce using rule 21 (line -> retorno .)


state 18

    (22) line -> declaration .

    ID              reduce using rule 22 (line -> declaration .)
    CASE            reduce using rule 22 (line -> declaration .)
    FOR             reduce using rule 22 (line -> declaration .)
    IF              reduce using rule 22 (line -> declaration .)
    FUNC            reduce using rule 22 (line -> declaration .)
    SWITCH          reduce using rule 22 (line -> declaration .)
    TYPE            reduce using rule 22 (line -> declaration .)
    RETURN          reduce using rule 22 (line -> declaration .)
    VAR             reduce using rule 22 (line -> declaration .)
    INT             reduce using rule 22 (line -> declaration .)
    FLOAT           reduce using rule 22 (line -> declaration .)
    $end            reduce using rule 22 (line -> declaration .)
    RCURLY          reduce using rule 22 (line -> declaration .)


state 19

    (36) stamentFor -> FOR . ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    ID              shift and go to state 33


state 20

    (38) consulta -> IF . expression LCURLY statements RCURLY
    (39) consulta -> IF . expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (26) expression -> . ID comparator ID
    (27) expression -> . ID comparator INT
    (28) expression -> . ID

    ID              shift and go to state 35

    expression                     shift and go to state 34

state 21

    (54) push -> FUNC . PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> FUNC . value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> FUNC . ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (56) func_declaration -> FUNC . ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (2) value -> . INT
    (3) value -> . FLOAT
    (4) value -> . STR
    (5) value -> . ID

    PUSH            shift and go to state 36
    ID              shift and go to state 37
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41

    value                          shift and go to state 38

state 22

    (25) retorno -> RETURN . retorno
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno

    ID              shift and go to state 43
    RETURN          shift and go to state 22

    retorno                        shift and go to state 42

state 23

    (68) mathExpProd -> mathExp .
    (69) mathExpProd -> mathExp . operator mathExpProd
    (32) operator -> . DIVIDE
    (33) operator -> . MINUS
    (34) operator -> . PLUS
    (35) operator -> . TIMES

    ID              reduce using rule 68 (mathExpProd -> mathExp .)
    CASE            reduce using rule 68 (mathExpProd -> mathExp .)
    FOR             reduce using rule 68 (mathExpProd -> mathExp .)
    IF              reduce using rule 68 (mathExpProd -> mathExp .)
    FUNC            reduce using rule 68 (mathExpProd -> mathExp .)
    SWITCH          reduce using rule 68 (mathExpProd -> mathExp .)
    TYPE            reduce using rule 68 (mathExpProd -> mathExp .)
    RETURN          reduce using rule 68 (mathExpProd -> mathExp .)
    VAR             reduce using rule 68 (mathExpProd -> mathExp .)
    INT             reduce using rule 68 (mathExpProd -> mathExp .)
    FLOAT           reduce using rule 68 (mathExpProd -> mathExp .)
    $end            reduce using rule 68 (mathExpProd -> mathExp .)
    RCURLY          reduce using rule 68 (mathExpProd -> mathExp .)
    DIVIDE          shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47
    TIMES           shift and go to state 48

    operator                       shift and go to state 44

state 24

    (37) switch -> SWITCH . ID LCURLY repeatLines RCURLY

    ID              shift and go to state 49


state 25

    (51) pila -> TYPE . STACK LBRACKETS RBRACKETS ID
    (52) pila -> TYPE . STACK INTERFACE LCURLY RCURLY
    (53) pila -> TYPE . STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY

    STACK           shift and go to state 50


state 26

    (63) declaration -> VAR . ID ID
    (64) declaration -> VAR . ID ID EQUALSVAR number
    (65) declaration -> VAR . ID ID EQUALSVAR STR

    ID              shift and go to state 51


state 27

    (66) mathExp -> number .
    (67) mathExp -> number . operator number
    (32) operator -> . DIVIDE
    (33) operator -> . MINUS
    (34) operator -> . PLUS
    (35) operator -> . TIMES

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    ID              reduce using rule 66 (mathExp -> number .)
    CASE            reduce using rule 66 (mathExp -> number .)
    FOR             reduce using rule 66 (mathExp -> number .)
    IF              reduce using rule 66 (mathExp -> number .)
    FUNC            reduce using rule 66 (mathExp -> number .)
    SWITCH          reduce using rule 66 (mathExp -> number .)
    TYPE            reduce using rule 66 (mathExp -> number .)
    RETURN          reduce using rule 66 (mathExp -> number .)
    VAR             reduce using rule 66 (mathExp -> number .)
    INT             reduce using rule 66 (mathExp -> number .)
    FLOAT           reduce using rule 66 (mathExp -> number .)
    $end            reduce using rule 66 (mathExp -> number .)
    RCURLY          reduce using rule 66 (mathExp -> number .)
    DIVIDE          shift and go to state 45
    MINUS           shift and go to state 46
    PLUS            shift and go to state 47
    TIMES           shift and go to state 48

  ! DIVIDE          [ reduce using rule 66 (mathExp -> number .) ]
  ! MINUS           [ reduce using rule 66 (mathExp -> number .) ]
  ! PLUS            [ reduce using rule 66 (mathExp -> number .) ]
  ! TIMES           [ reduce using rule 66 (mathExp -> number .) ]

    operator                       shift and go to state 52

state 28

    (44) number -> FLOAT .

    DIVIDE          reduce using rule 44 (number -> FLOAT .)
    MINUS           reduce using rule 44 (number -> FLOAT .)
    PLUS            reduce using rule 44 (number -> FLOAT .)
    TIMES           reduce using rule 44 (number -> FLOAT .)
    ID              reduce using rule 44 (number -> FLOAT .)
    CASE            reduce using rule 44 (number -> FLOAT .)
    FOR             reduce using rule 44 (number -> FLOAT .)
    IF              reduce using rule 44 (number -> FLOAT .)
    FUNC            reduce using rule 44 (number -> FLOAT .)
    SWITCH          reduce using rule 44 (number -> FLOAT .)
    TYPE            reduce using rule 44 (number -> FLOAT .)
    RETURN          reduce using rule 44 (number -> FLOAT .)
    VAR             reduce using rule 44 (number -> FLOAT .)
    INT             reduce using rule 44 (number -> FLOAT .)
    FLOAT           reduce using rule 44 (number -> FLOAT .)
    $end            reduce using rule 44 (number -> FLOAT .)
    RCURLY          reduce using rule 44 (number -> FLOAT .)
    COMMA           reduce using rule 44 (number -> FLOAT .)


state 29

    (7) repeatLines -> line repeatLines .

    $end            reduce using rule 7 (repeatLines -> line repeatLines .)
    RCURLY          reduce using rule 7 (repeatLines -> line repeatLines .)
    RETURN          reduce using rule 7 (repeatLines -> line repeatLines .)


state 30

    (8) line -> ID EQUALSVAR . value
    (20) line -> ID EQUALSVAR . INT
    (45) array -> ID EQUALSVAR . LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> ID EQUALSVAR . LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (2) value -> . INT
    (3) value -> . FLOAT
    (4) value -> . STR
    (5) value -> . ID

    INT             shift and go to state 55
    LBRACKETS       shift and go to state 56
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    ID              shift and go to state 53

    value                          shift and go to state 54

state 31

    (24) retorno -> ID COMMA .

    ID              reduce using rule 24 (retorno -> ID COMMA .)
    CASE            reduce using rule 24 (retorno -> ID COMMA .)
    FOR             reduce using rule 24 (retorno -> ID COMMA .)
    IF              reduce using rule 24 (retorno -> ID COMMA .)
    FUNC            reduce using rule 24 (retorno -> ID COMMA .)
    SWITCH          reduce using rule 24 (retorno -> ID COMMA .)
    TYPE            reduce using rule 24 (retorno -> ID COMMA .)
    RETURN          reduce using rule 24 (retorno -> ID COMMA .)
    VAR             reduce using rule 24 (retorno -> ID COMMA .)
    INT             reduce using rule 24 (retorno -> ID COMMA .)
    FLOAT           reduce using rule 24 (retorno -> ID COMMA .)
    $end            reduce using rule 24 (retorno -> ID COMMA .)
    RCURLY          reduce using rule 24 (retorno -> ID COMMA .)


state 32

    (16) line -> CASE INT . TWODOTS line

    TWODOTS         shift and go to state 57


state 33

    (36) stamentFor -> FOR ID . EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    EQUALS          shift and go to state 58


state 34

    (38) consulta -> IF expression . LCURLY statements RCURLY
    (39) consulta -> IF expression . LCURLY statements RCURLY ELSE LCURLY statements RCURLY

    LCURLY          shift and go to state 59


state 35

    (26) expression -> ID . comparator ID
    (27) expression -> ID . comparator INT
    (28) expression -> ID .
    (29) comparator -> . COMPARE
    (30) comparator -> . MORETHAN
    (31) comparator -> . MINUSTHAN

    LCURLY          reduce using rule 28 (expression -> ID .)
    COMPARE         shift and go to state 61
    MORETHAN        shift and go to state 62
    MINUSTHAN       shift and go to state 63

    comparator                     shift and go to state 60

state 36

    (54) push -> FUNC PUSH . LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    LPAREN          shift and go to state 64


state 37

    (59) funcion -> FUNC ID . LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (56) func_declaration -> FUNC ID . LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (5) value -> ID .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 65

  ! LPAREN          [ reduce using rule 5 (value -> ID .) ]


state 38

    (55) funcion -> FUNC value . LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY

    LPAREN          shift and go to state 66


state 39

    (2) value -> INT .

    LPAREN          reduce using rule 2 (value -> INT .)
    ID              reduce using rule 2 (value -> INT .)
    RCURLY          reduce using rule 2 (value -> INT .)


state 40

    (3) value -> FLOAT .

    LPAREN          reduce using rule 3 (value -> FLOAT .)
    ID              reduce using rule 3 (value -> FLOAT .)
    CASE            reduce using rule 3 (value -> FLOAT .)
    FOR             reduce using rule 3 (value -> FLOAT .)
    IF              reduce using rule 3 (value -> FLOAT .)
    FUNC            reduce using rule 3 (value -> FLOAT .)
    SWITCH          reduce using rule 3 (value -> FLOAT .)
    TYPE            reduce using rule 3 (value -> FLOAT .)
    RETURN          reduce using rule 3 (value -> FLOAT .)
    VAR             reduce using rule 3 (value -> FLOAT .)
    INT             reduce using rule 3 (value -> FLOAT .)
    FLOAT           reduce using rule 3 (value -> FLOAT .)
    $end            reduce using rule 3 (value -> FLOAT .)
    RCURLY          reduce using rule 3 (value -> FLOAT .)


state 41

    (4) value -> STR .

    LPAREN          reduce using rule 4 (value -> STR .)
    ID              reduce using rule 4 (value -> STR .)
    CASE            reduce using rule 4 (value -> STR .)
    FOR             reduce using rule 4 (value -> STR .)
    IF              reduce using rule 4 (value -> STR .)
    FUNC            reduce using rule 4 (value -> STR .)
    SWITCH          reduce using rule 4 (value -> STR .)
    TYPE            reduce using rule 4 (value -> STR .)
    RETURN          reduce using rule 4 (value -> STR .)
    VAR             reduce using rule 4 (value -> STR .)
    INT             reduce using rule 4 (value -> STR .)
    FLOAT           reduce using rule 4 (value -> STR .)
    $end            reduce using rule 4 (value -> STR .)
    RCURLY          reduce using rule 4 (value -> STR .)


state 42

    (25) retorno -> RETURN retorno .

    ID              reduce using rule 25 (retorno -> RETURN retorno .)
    CASE            reduce using rule 25 (retorno -> RETURN retorno .)
    FOR             reduce using rule 25 (retorno -> RETURN retorno .)
    IF              reduce using rule 25 (retorno -> RETURN retorno .)
    FUNC            reduce using rule 25 (retorno -> RETURN retorno .)
    SWITCH          reduce using rule 25 (retorno -> RETURN retorno .)
    TYPE            reduce using rule 25 (retorno -> RETURN retorno .)
    RETURN          reduce using rule 25 (retorno -> RETURN retorno .)
    VAR             reduce using rule 25 (retorno -> RETURN retorno .)
    INT             reduce using rule 25 (retorno -> RETURN retorno .)
    FLOAT           reduce using rule 25 (retorno -> RETURN retorno .)
    $end            reduce using rule 25 (retorno -> RETURN retorno .)
    RCURLY          reduce using rule 25 (retorno -> RETURN retorno .)


state 43

    (23) retorno -> ID .
    (24) retorno -> ID . COMMA

    ID              reduce using rule 23 (retorno -> ID .)
    CASE            reduce using rule 23 (retorno -> ID .)
    FOR             reduce using rule 23 (retorno -> ID .)
    IF              reduce using rule 23 (retorno -> ID .)
    FUNC            reduce using rule 23 (retorno -> ID .)
    SWITCH          reduce using rule 23 (retorno -> ID .)
    TYPE            reduce using rule 23 (retorno -> ID .)
    RETURN          reduce using rule 23 (retorno -> ID .)
    VAR             reduce using rule 23 (retorno -> ID .)
    INT             reduce using rule 23 (retorno -> ID .)
    FLOAT           reduce using rule 23 (retorno -> ID .)
    $end            reduce using rule 23 (retorno -> ID .)
    RCURLY          reduce using rule 23 (retorno -> ID .)
    COMMA           shift and go to state 31


state 44

    (69) mathExpProd -> mathExp operator . mathExpProd
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    mathExp                        shift and go to state 23
    mathExpProd                    shift and go to state 67
    number                         shift and go to state 27

state 45

    (32) operator -> DIVIDE .

    INT             reduce using rule 32 (operator -> DIVIDE .)
    FLOAT           reduce using rule 32 (operator -> DIVIDE .)


state 46

    (33) operator -> MINUS .

    INT             reduce using rule 33 (operator -> MINUS .)
    FLOAT           reduce using rule 33 (operator -> MINUS .)


state 47

    (34) operator -> PLUS .

    INT             reduce using rule 34 (operator -> PLUS .)
    FLOAT           reduce using rule 34 (operator -> PLUS .)


state 48

    (35) operator -> TIMES .

    INT             reduce using rule 35 (operator -> TIMES .)
    FLOAT           reduce using rule 35 (operator -> TIMES .)


state 49

    (37) switch -> SWITCH ID . LCURLY repeatLines RCURLY

    LCURLY          shift and go to state 68


state 50

    (51) pila -> TYPE STACK . LBRACKETS RBRACKETS ID
    (52) pila -> TYPE STACK . INTERFACE LCURLY RCURLY
    (53) pila -> TYPE STACK . STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY

    LBRACKETS       shift and go to state 69
    INTERFACE       shift and go to state 70
    STRUCT          shift and go to state 71


state 51

    (63) declaration -> VAR ID . ID
    (64) declaration -> VAR ID . ID EQUALSVAR number
    (65) declaration -> VAR ID . ID EQUALSVAR STR

    ID              shift and go to state 72


state 52

    (67) mathExp -> number operator . number
    (43) number -> . INT
    (44) number -> . FLOAT

    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    number                         shift and go to state 73

state 53

    (5) value -> ID .

    ID              reduce using rule 5 (value -> ID .)
    CASE            reduce using rule 5 (value -> ID .)
    FOR             reduce using rule 5 (value -> ID .)
    IF              reduce using rule 5 (value -> ID .)
    FUNC            reduce using rule 5 (value -> ID .)
    SWITCH          reduce using rule 5 (value -> ID .)
    TYPE            reduce using rule 5 (value -> ID .)
    RETURN          reduce using rule 5 (value -> ID .)
    VAR             reduce using rule 5 (value -> ID .)
    INT             reduce using rule 5 (value -> ID .)
    FLOAT           reduce using rule 5 (value -> ID .)
    $end            reduce using rule 5 (value -> ID .)
    RCURLY          reduce using rule 5 (value -> ID .)


state 54

    (8) line -> ID EQUALSVAR value .

    ID              reduce using rule 8 (line -> ID EQUALSVAR value .)
    CASE            reduce using rule 8 (line -> ID EQUALSVAR value .)
    FOR             reduce using rule 8 (line -> ID EQUALSVAR value .)
    IF              reduce using rule 8 (line -> ID EQUALSVAR value .)
    FUNC            reduce using rule 8 (line -> ID EQUALSVAR value .)
    SWITCH          reduce using rule 8 (line -> ID EQUALSVAR value .)
    TYPE            reduce using rule 8 (line -> ID EQUALSVAR value .)
    RETURN          reduce using rule 8 (line -> ID EQUALSVAR value .)
    VAR             reduce using rule 8 (line -> ID EQUALSVAR value .)
    INT             reduce using rule 8 (line -> ID EQUALSVAR value .)
    FLOAT           reduce using rule 8 (line -> ID EQUALSVAR value .)
    $end            reduce using rule 8 (line -> ID EQUALSVAR value .)
    RCURLY          reduce using rule 8 (line -> ID EQUALSVAR value .)


state 55

    (20) line -> ID EQUALSVAR INT .
    (2) value -> INT .

  ! reduce/reduce conflict for ID resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for CASE resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for FOR resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for IF resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for FUNC resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for TYPE resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for RETURN resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for VAR resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for INT resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for $end resolved using rule 2 (value -> INT .)
  ! reduce/reduce conflict for RCURLY resolved using rule 2 (value -> INT .)
    ID              reduce using rule 2 (value -> INT .)
    CASE            reduce using rule 2 (value -> INT .)
    FOR             reduce using rule 2 (value -> INT .)
    IF              reduce using rule 2 (value -> INT .)
    FUNC            reduce using rule 2 (value -> INT .)
    SWITCH          reduce using rule 2 (value -> INT .)
    TYPE            reduce using rule 2 (value -> INT .)
    RETURN          reduce using rule 2 (value -> INT .)
    VAR             reduce using rule 2 (value -> INT .)
    INT             reduce using rule 2 (value -> INT .)
    FLOAT           reduce using rule 2 (value -> INT .)
    $end            reduce using rule 2 (value -> INT .)
    RCURLY          reduce using rule 2 (value -> INT .)

  ! ID              [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! CASE            [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! FOR             [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! IF              [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! FUNC            [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! SWITCH          [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! TYPE            [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! RETURN          [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! VAR             [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! INT             [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! FLOAT           [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! $end            [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]
  ! RCURLY          [ reduce using rule 20 (line -> ID EQUALSVAR INT .) ]


state 56

    (45) array -> ID EQUALSVAR LBRACKETS . INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> ID EQUALSVAR LBRACKETS . RBRACKETS ID LCURLY elemSlice RCURLY

    INT             shift and go to state 74
    RBRACKETS       shift and go to state 75


state 57

    (16) line -> CASE INT TWODOTS . line
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    line                           shift and go to state 76
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 58

    (36) stamentFor -> FOR ID EQUALS . INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    INT             shift and go to state 77


state 59

    (38) consulta -> IF expression LCURLY . statements RCURLY
    (39) consulta -> IF expression LCURLY . statements RCURLY ELSE LCURLY statements RCURLY
    (40) statements -> . statement
    (41) statements -> . statement COMMA statements
    (42) statement -> . ID

    ID              shift and go to state 80

    statements                     shift and go to state 78
    statement                      shift and go to state 79

state 60

    (26) expression -> ID comparator . ID
    (27) expression -> ID comparator . INT

    ID              shift and go to state 81
    INT             shift and go to state 82


state 61

    (29) comparator -> COMPARE .

    ID              reduce using rule 29 (comparator -> COMPARE .)
    INT             reduce using rule 29 (comparator -> COMPARE .)


state 62

    (30) comparator -> MORETHAN .

    ID              reduce using rule 30 (comparator -> MORETHAN .)
    INT             reduce using rule 30 (comparator -> MORETHAN .)


state 63

    (31) comparator -> MINUSTHAN .

    ID              reduce using rule 31 (comparator -> MINUSTHAN .)
    INT             reduce using rule 31 (comparator -> MINUSTHAN .)


state 64

    (54) push -> FUNC PUSH LPAREN . ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    ID              shift and go to state 83


state 65

    (59) funcion -> FUNC ID LPAREN . param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (56) func_declaration -> FUNC ID LPAREN . RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (60) param_list -> . param
    (61) param_list -> . param_list COMMA param
    (62) param -> . value ID
    (2) value -> . INT
    (3) value -> . FLOAT
    (4) value -> . STR
    (5) value -> . ID

    RPAREN          shift and go to state 85
    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    ID              shift and go to state 53

    param_list                     shift and go to state 84
    param                          shift and go to state 86
    value                          shift and go to state 87

state 66

    (55) funcion -> FUNC value LPAREN . RPAREN ID LCURLY repeatLines RETURN ID RCURLY

    RPAREN          shift and go to state 88


state 67

    (69) mathExpProd -> mathExp operator mathExpProd .

    ID              reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    CASE            reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    FOR             reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    IF              reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    FUNC            reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    SWITCH          reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    TYPE            reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    RETURN          reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    VAR             reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    INT             reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    FLOAT           reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    $end            reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)
    RCURLY          reduce using rule 69 (mathExpProd -> mathExp operator mathExpProd .)


state 68

    (37) switch -> SWITCH ID LCURLY . repeatLines RCURLY
    (6) repeatLines -> . line
    (7) repeatLines -> . line repeatLines
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    repeatLines                    shift and go to state 89
    line                           shift and go to state 3
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 69

    (51) pila -> TYPE STACK LBRACKETS . RBRACKETS ID

    RBRACKETS       shift and go to state 90


state 70

    (52) pila -> TYPE STACK INTERFACE . LCURLY RCURLY

    LCURLY          shift and go to state 91


state 71

    (53) pila -> TYPE STACK STRUCT . LCURLY ID LBRACKETS RBRACKETS value RCURLY

    LCURLY          shift and go to state 92


state 72

    (63) declaration -> VAR ID ID .
    (64) declaration -> VAR ID ID . EQUALSVAR number
    (65) declaration -> VAR ID ID . EQUALSVAR STR

    ID              reduce using rule 63 (declaration -> VAR ID ID .)
    CASE            reduce using rule 63 (declaration -> VAR ID ID .)
    FOR             reduce using rule 63 (declaration -> VAR ID ID .)
    IF              reduce using rule 63 (declaration -> VAR ID ID .)
    FUNC            reduce using rule 63 (declaration -> VAR ID ID .)
    SWITCH          reduce using rule 63 (declaration -> VAR ID ID .)
    TYPE            reduce using rule 63 (declaration -> VAR ID ID .)
    RETURN          reduce using rule 63 (declaration -> VAR ID ID .)
    VAR             reduce using rule 63 (declaration -> VAR ID ID .)
    INT             reduce using rule 63 (declaration -> VAR ID ID .)
    FLOAT           reduce using rule 63 (declaration -> VAR ID ID .)
    $end            reduce using rule 63 (declaration -> VAR ID ID .)
    RCURLY          reduce using rule 63 (declaration -> VAR ID ID .)
    EQUALSVAR       shift and go to state 93


state 73

    (67) mathExp -> number operator number .

    DIVIDE          reduce using rule 67 (mathExp -> number operator number .)
    MINUS           reduce using rule 67 (mathExp -> number operator number .)
    PLUS            reduce using rule 67 (mathExp -> number operator number .)
    TIMES           reduce using rule 67 (mathExp -> number operator number .)
    ID              reduce using rule 67 (mathExp -> number operator number .)
    CASE            reduce using rule 67 (mathExp -> number operator number .)
    FOR             reduce using rule 67 (mathExp -> number operator number .)
    IF              reduce using rule 67 (mathExp -> number operator number .)
    FUNC            reduce using rule 67 (mathExp -> number operator number .)
    SWITCH          reduce using rule 67 (mathExp -> number operator number .)
    TYPE            reduce using rule 67 (mathExp -> number operator number .)
    RETURN          reduce using rule 67 (mathExp -> number operator number .)
    VAR             reduce using rule 67 (mathExp -> number operator number .)
    INT             reduce using rule 67 (mathExp -> number operator number .)
    FLOAT           reduce using rule 67 (mathExp -> number operator number .)
    $end            reduce using rule 67 (mathExp -> number operator number .)
    RCURLY          reduce using rule 67 (mathExp -> number operator number .)


state 74

    (45) array -> ID EQUALSVAR LBRACKETS INT . RBRACKETS ID LCURLY elemArray RCURLY

    RBRACKETS       shift and go to state 94


state 75

    (48) slice -> ID EQUALSVAR LBRACKETS RBRACKETS . ID LCURLY elemSlice RCURLY

    ID              shift and go to state 95


state 76

    (16) line -> CASE INT TWODOTS line .

    ID              reduce using rule 16 (line -> CASE INT TWODOTS line .)
    CASE            reduce using rule 16 (line -> CASE INT TWODOTS line .)
    FOR             reduce using rule 16 (line -> CASE INT TWODOTS line .)
    IF              reduce using rule 16 (line -> CASE INT TWODOTS line .)
    FUNC            reduce using rule 16 (line -> CASE INT TWODOTS line .)
    SWITCH          reduce using rule 16 (line -> CASE INT TWODOTS line .)
    TYPE            reduce using rule 16 (line -> CASE INT TWODOTS line .)
    RETURN          reduce using rule 16 (line -> CASE INT TWODOTS line .)
    VAR             reduce using rule 16 (line -> CASE INT TWODOTS line .)
    INT             reduce using rule 16 (line -> CASE INT TWODOTS line .)
    FLOAT           reduce using rule 16 (line -> CASE INT TWODOTS line .)
    $end            reduce using rule 16 (line -> CASE INT TWODOTS line .)
    RCURLY          reduce using rule 16 (line -> CASE INT TWODOTS line .)


state 77

    (36) stamentFor -> FOR ID EQUALS INT . DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    DOTCOMA         shift and go to state 96


state 78

    (38) consulta -> IF expression LCURLY statements . RCURLY
    (39) consulta -> IF expression LCURLY statements . RCURLY ELSE LCURLY statements RCURLY

    RCURLY          shift and go to state 97


state 79

    (40) statements -> statement .
    (41) statements -> statement . COMMA statements

    RCURLY          reduce using rule 40 (statements -> statement .)
    COMMA           shift and go to state 98


state 80

    (42) statement -> ID .

    COMMA           reduce using rule 42 (statement -> ID .)
    RCURLY          reduce using rule 42 (statement -> ID .)


state 81

    (26) expression -> ID comparator ID .

    LCURLY          reduce using rule 26 (expression -> ID comparator ID .)


state 82

    (27) expression -> ID comparator INT .

    LCURLY          reduce using rule 27 (expression -> ID comparator INT .)


state 83

    (54) push -> FUNC PUSH LPAREN ID . STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    STACK           shift and go to state 99


state 84

    (59) funcion -> FUNC ID LPAREN param_list . RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (61) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 100
    COMMA           shift and go to state 101


state 85

    (56) func_declaration -> FUNC ID LPAREN RPAREN . LPAREN return_types RPAREN LCURLY repeatLines RCURLY

    LPAREN          shift and go to state 102


state 86

    (60) param_list -> param .

    RPAREN          reduce using rule 60 (param_list -> param .)
    COMMA           reduce using rule 60 (param_list -> param .)


state 87

    (62) param -> value . ID

    ID              shift and go to state 103


state 88

    (55) funcion -> FUNC value LPAREN RPAREN . ID LCURLY repeatLines RETURN ID RCURLY

    ID              shift and go to state 104


state 89

    (37) switch -> SWITCH ID LCURLY repeatLines . RCURLY

    RCURLY          shift and go to state 105


state 90

    (51) pila -> TYPE STACK LBRACKETS RBRACKETS . ID

    ID              shift and go to state 106


state 91

    (52) pila -> TYPE STACK INTERFACE LCURLY . RCURLY

    RCURLY          shift and go to state 107


state 92

    (53) pila -> TYPE STACK STRUCT LCURLY . ID LBRACKETS RBRACKETS value RCURLY

    ID              shift and go to state 108


state 93

    (64) declaration -> VAR ID ID EQUALSVAR . number
    (65) declaration -> VAR ID ID EQUALSVAR . STR
    (43) number -> . INT
    (44) number -> . FLOAT

    STR             shift and go to state 110
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    number                         shift and go to state 109

state 94

    (45) array -> ID EQUALSVAR LBRACKETS INT RBRACKETS . ID LCURLY elemArray RCURLY

    ID              shift and go to state 111


state 95

    (48) slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID . LCURLY elemSlice RCURLY

    LCURLY          shift and go to state 112


state 96

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA . ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    ID              shift and go to state 113


state 97

    (38) consulta -> IF expression LCURLY statements RCURLY .
    (39) consulta -> IF expression LCURLY statements RCURLY . ELSE LCURLY statements RCURLY

    ID              reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    CASE            reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    FOR             reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    IF              reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    FUNC            reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    SWITCH          reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    TYPE            reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    RETURN          reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    VAR             reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    INT             reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    FLOAT           reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    $end            reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    RCURLY          reduce using rule 38 (consulta -> IF expression LCURLY statements RCURLY .)
    ELSE            shift and go to state 114


state 98

    (41) statements -> statement COMMA . statements
    (40) statements -> . statement
    (41) statements -> . statement COMMA statements
    (42) statement -> . ID

    ID              shift and go to state 80

    statement                      shift and go to state 79
    statements                     shift and go to state 115

state 99

    (54) push -> FUNC PUSH LPAREN ID STACK . COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    COMMA           shift and go to state 116


state 100

    (59) funcion -> FUNC ID LPAREN param_list RPAREN . ID LCURLY repeatLines RETURN ID RCURLY

    ID              shift and go to state 117


state 101

    (61) param_list -> param_list COMMA . param
    (62) param -> . value ID
    (2) value -> . INT
    (3) value -> . FLOAT
    (4) value -> . STR
    (5) value -> . ID

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    ID              shift and go to state 53

    param                          shift and go to state 118
    value                          shift and go to state 87

state 102

    (56) func_declaration -> FUNC ID LPAREN RPAREN LPAREN . return_types RPAREN LCURLY repeatLines RCURLY
    (57) return_types -> . ID COMMA ID
    (58) return_types -> . ID

    ID              shift and go to state 119

    return_types                   shift and go to state 120

state 103

    (62) param -> value ID .

    RPAREN          reduce using rule 62 (param -> value ID .)
    COMMA           reduce using rule 62 (param -> value ID .)


state 104

    (55) funcion -> FUNC value LPAREN RPAREN ID . LCURLY repeatLines RETURN ID RCURLY

    LCURLY          shift and go to state 121


state 105

    (37) switch -> SWITCH ID LCURLY repeatLines RCURLY .

    ID              reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    CASE            reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    FOR             reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    IF              reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    FUNC            reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    SWITCH          reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    TYPE            reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    RETURN          reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    VAR             reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    INT             reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    FLOAT           reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    $end            reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)
    RCURLY          reduce using rule 37 (switch -> SWITCH ID LCURLY repeatLines RCURLY .)


state 106

    (51) pila -> TYPE STACK LBRACKETS RBRACKETS ID .

    ID              reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    CASE            reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    FOR             reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    IF              reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    FUNC            reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    SWITCH          reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    TYPE            reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    RETURN          reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    VAR             reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    INT             reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    FLOAT           reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    $end            reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)
    RCURLY          reduce using rule 51 (pila -> TYPE STACK LBRACKETS RBRACKETS ID .)


state 107

    (52) pila -> TYPE STACK INTERFACE LCURLY RCURLY .

    ID              reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    CASE            reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    FOR             reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    IF              reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    FUNC            reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    SWITCH          reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    TYPE            reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    RETURN          reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    VAR             reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    INT             reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    FLOAT           reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    $end            reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)
    RCURLY          reduce using rule 52 (pila -> TYPE STACK INTERFACE LCURLY RCURLY .)


state 108

    (53) pila -> TYPE STACK STRUCT LCURLY ID . LBRACKETS RBRACKETS value RCURLY

    LBRACKETS       shift and go to state 122


state 109

    (64) declaration -> VAR ID ID EQUALSVAR number .

    ID              reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    CASE            reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    FOR             reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    IF              reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    FUNC            reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    SWITCH          reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    TYPE            reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    RETURN          reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    VAR             reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    INT             reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    FLOAT           reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    $end            reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)
    RCURLY          reduce using rule 64 (declaration -> VAR ID ID EQUALSVAR number .)


state 110

    (65) declaration -> VAR ID ID EQUALSVAR STR .

    ID              reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    CASE            reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    FOR             reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    IF              reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    FUNC            reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    SWITCH          reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    TYPE            reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    RETURN          reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    VAR             reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    INT             reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    FLOAT           reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    $end            reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)
    RCURLY          reduce using rule 65 (declaration -> VAR ID ID EQUALSVAR STR .)


state 111

    (45) array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID . LCURLY elemArray RCURLY

    LCURLY          shift and go to state 123


state 112

    (48) slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY . elemSlice RCURLY
    (49) elemSlice -> . number
    (50) elemSlice -> . number COMMA elemSlice
    (43) number -> . INT
    (44) number -> . FLOAT

    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    elemSlice                      shift and go to state 124
    number                         shift and go to state 125

state 113

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID . MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    MINUSTHAN       shift and go to state 126


state 114

    (39) consulta -> IF expression LCURLY statements RCURLY ELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 127


state 115

    (41) statements -> statement COMMA statements .

    RCURLY          reduce using rule 41 (statements -> statement COMMA statements .)


state 116

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA . ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    ID              shift and go to state 128


state 117

    (59) funcion -> FUNC ID LPAREN param_list RPAREN ID . LCURLY repeatLines RETURN ID RCURLY

    LCURLY          shift and go to state 129


state 118

    (61) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 61 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 61 (param_list -> param_list COMMA param .)


state 119

    (57) return_types -> ID . COMMA ID
    (58) return_types -> ID .

    COMMA           shift and go to state 130
    RPAREN          reduce using rule 58 (return_types -> ID .)


state 120

    (56) func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types . RPAREN LCURLY repeatLines RCURLY

    RPAREN          shift and go to state 131


state 121

    (55) funcion -> FUNC value LPAREN RPAREN ID LCURLY . repeatLines RETURN ID RCURLY
    (6) repeatLines -> . line
    (7) repeatLines -> . line repeatLines
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    repeatLines                    shift and go to state 132
    line                           shift and go to state 3
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 122

    (53) pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS . RBRACKETS value RCURLY

    RBRACKETS       shift and go to state 133


state 123

    (45) array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY . elemArray RCURLY
    (46) elemArray -> . number
    (47) elemArray -> . number COMMA elemArray
    (43) number -> . INT
    (44) number -> . FLOAT

    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    elemArray                      shift and go to state 134
    number                         shift and go to state 135

state 124

    (48) slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice . RCURLY

    RCURLY          shift and go to state 136


state 125

    (49) elemSlice -> number .
    (50) elemSlice -> number . COMMA elemSlice

    RCURLY          reduce using rule 49 (elemSlice -> number .)
    COMMA           shift and go to state 137


state 126

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN . LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    LEN             shift and go to state 138


state 127

    (39) consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY . statements RCURLY
    (40) statements -> . statement
    (41) statements -> . statement COMMA statements
    (42) statement -> . ID

    ID              shift and go to state 80

    statements                     shift and go to state 139
    statement                      shift and go to state 79

state 128

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID . ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    ID              shift and go to state 140


state 129

    (59) funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY . repeatLines RETURN ID RCURLY
    (6) repeatLines -> . line
    (7) repeatLines -> . line repeatLines
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    repeatLines                    shift and go to state 141
    line                           shift and go to state 3
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 130

    (57) return_types -> ID COMMA . ID

    ID              shift and go to state 142


state 131

    (56) func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN . LCURLY repeatLines RCURLY

    LCURLY          shift and go to state 143


state 132

    (55) funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines . RETURN ID RCURLY

    RETURN          shift and go to state 144


state 133

    (53) pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS . value RCURLY
    (2) value -> . INT
    (3) value -> . FLOAT
    (4) value -> . STR
    (5) value -> . ID

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STR             shift and go to state 41
    ID              shift and go to state 53

    value                          shift and go to state 145

state 134

    (45) array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray . RCURLY

    RCURLY          shift and go to state 146


state 135

    (46) elemArray -> number .
    (47) elemArray -> number . COMMA elemArray

    RCURLY          reduce using rule 46 (elemArray -> number .)
    COMMA           shift and go to state 147


state 136

    (48) slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .

    ID              reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    CASE            reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    FOR             reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    IF              reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    FUNC            reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    SWITCH          reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    TYPE            reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    RETURN          reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    VAR             reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    INT             reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    FLOAT           reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    $end            reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)
    RCURLY          reduce using rule 48 (slice -> ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY .)


state 137

    (50) elemSlice -> number COMMA . elemSlice
    (49) elemSlice -> . number
    (50) elemSlice -> . number COMMA elemSlice
    (43) number -> . INT
    (44) number -> . FLOAT

    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    number                         shift and go to state 125
    elemSlice                      shift and go to state 148

state 138

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN . LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    LPAREN          shift and go to state 149


state 139

    (39) consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 150


state 140

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID . RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    RPAREN          shift and go to state 151


state 141

    (59) funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines . RETURN ID RCURLY

    RETURN          shift and go to state 152


state 142

    (57) return_types -> ID COMMA ID .

    RPAREN          reduce using rule 57 (return_types -> ID COMMA ID .)


state 143

    (56) func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY . repeatLines RCURLY
    (6) repeatLines -> . line
    (7) repeatLines -> . line repeatLines
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    repeatLines                    shift and go to state 153
    line                           shift and go to state 3
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 144

    (55) funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN . ID RCURLY

    ID              shift and go to state 154


state 145

    (53) pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value . RCURLY

    RCURLY          shift and go to state 155


state 146

    (45) array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .

    ID              reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    CASE            reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    FOR             reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    IF              reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    FUNC            reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    SWITCH          reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    TYPE            reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    RETURN          reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    VAR             reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    INT             reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    FLOAT           reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    $end            reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)
    RCURLY          reduce using rule 45 (array -> ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY .)


state 147

    (47) elemArray -> number COMMA . elemArray
    (46) elemArray -> . number
    (47) elemArray -> . number COMMA elemArray
    (43) number -> . INT
    (44) number -> . FLOAT

    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    number                         shift and go to state 135
    elemArray                      shift and go to state 156

state 148

    (50) elemSlice -> number COMMA elemSlice .

    RCURLY          reduce using rule 50 (elemSlice -> number COMMA elemSlice .)


state 149

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN . ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    ID              shift and go to state 157


state 150

    (39) consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .

    ID              reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    CASE            reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    IF              reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    FUNC            reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    SWITCH          reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    TYPE            reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    VAR             reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    INT             reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    FLOAT           reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    $end            reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 39 (consulta -> IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)


state 151

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN . STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    STACK           shift and go to state 158


state 152

    (59) funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN . ID RCURLY

    ID              shift and go to state 159


state 153

    (56) func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines . RCURLY

    RCURLY          shift and go to state 160


state 154

    (55) funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID . RCURLY

    RCURLY          shift and go to state 161


state 155

    (53) pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .

    ID              reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    CASE            reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    FOR             reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    IF              reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    FUNC            reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    SWITCH          reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    TYPE            reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    RETURN          reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    VAR             reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    INT             reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    FLOAT           reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    $end            reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)
    RCURLY          reduce using rule 53 (pila -> TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY .)


state 156

    (47) elemArray -> number COMMA elemArray .

    RCURLY          reduce using rule 47 (elemArray -> number COMMA elemArray .)


state 157

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID . RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    RPAREN          shift and go to state 162


state 158

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK . LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    LCURLY          shift and go to state 163


state 159

    (59) funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID . RCURLY

    RCURLY          shift and go to state 164


state 160

    (56) func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .

    ID              reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    CASE            reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    FOR             reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    IF              reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    FUNC            reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    SWITCH          reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    TYPE            reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    RETURN          reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    VAR             reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    INT             reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    FLOAT           reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    $end            reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)
    RCURLY          reduce using rule 56 (func_declaration -> FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY .)


state 161

    (55) funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .

    ID              reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    CASE            reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    FOR             reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    IF              reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    FUNC            reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    SWITCH          reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    TYPE            reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    RETURN          reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    VAR             reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    INT             reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    FLOAT           reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    $end            reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    RCURLY          reduce using rule 55 (funcion -> FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)


state 162

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN . DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY

    DOTCOMA         shift and go to state 165


state 163

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY . RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY

    RETURN          shift and go to state 166


state 164

    (59) funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .

    ID              reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    CASE            reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    FOR             reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    IF              reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    FUNC            reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    SWITCH          reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    TYPE            reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    RETURN          reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    VAR             reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    INT             reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    FLOAT           reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    $end            reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)
    RCURLY          reduce using rule 59 (funcion -> FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY .)


state 165

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA . ID PLUS PLUS LCURLY repeatLines RCURLY

    ID              shift and go to state 167


state 166

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN . APPEND LPAREN ID COMMA ID RPAREN RCURLY

    APPEND          shift and go to state 168


state 167

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID . PLUS PLUS LCURLY repeatLines RCURLY

    PLUS            shift and go to state 169


state 168

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND . LPAREN ID COMMA ID RPAREN RCURLY

    LPAREN          shift and go to state 170


state 169

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS . PLUS LCURLY repeatLines RCURLY

    PLUS            shift and go to state 171


state 170

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN . ID COMMA ID RPAREN RCURLY

    ID              shift and go to state 172


state 171

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS . LCURLY repeatLines RCURLY

    LCURLY          shift and go to state 173


state 172

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID . COMMA ID RPAREN RCURLY

    COMMA           shift and go to state 174


state 173

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY . repeatLines RCURLY
    (6) repeatLines -> . line
    (7) repeatLines -> . line repeatLines
    (8) line -> . ID EQUALSVAR value
    (9) line -> . stamentFor
    (10) line -> . consulta
    (11) line -> . push
    (12) line -> . funcion
    (13) line -> . array
    (14) line -> . slice
    (15) line -> . mathExpProd
    (16) line -> . CASE INT TWODOTS line
    (17) line -> . switch
    (18) line -> . pila
    (19) line -> . func_declaration
    (20) line -> . ID EQUALSVAR INT
    (21) line -> . retorno
    (22) line -> . declaration
    (36) stamentFor -> . FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY
    (38) consulta -> . IF expression LCURLY statements RCURLY
    (39) consulta -> . IF expression LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (54) push -> . FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY
    (55) funcion -> . FUNC value LPAREN RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (59) funcion -> . FUNC ID LPAREN param_list RPAREN ID LCURLY repeatLines RETURN ID RCURLY
    (45) array -> . ID EQUALSVAR LBRACKETS INT RBRACKETS ID LCURLY elemArray RCURLY
    (48) slice -> . ID EQUALSVAR LBRACKETS RBRACKETS ID LCURLY elemSlice RCURLY
    (68) mathExpProd -> . mathExp
    (69) mathExpProd -> . mathExp operator mathExpProd
    (37) switch -> . SWITCH ID LCURLY repeatLines RCURLY
    (51) pila -> . TYPE STACK LBRACKETS RBRACKETS ID
    (52) pila -> . TYPE STACK INTERFACE LCURLY RCURLY
    (53) pila -> . TYPE STACK STRUCT LCURLY ID LBRACKETS RBRACKETS value RCURLY
    (56) func_declaration -> . FUNC ID LPAREN RPAREN LPAREN return_types RPAREN LCURLY repeatLines RCURLY
    (23) retorno -> . ID
    (24) retorno -> . ID COMMA
    (25) retorno -> . RETURN retorno
    (63) declaration -> . VAR ID ID
    (64) declaration -> . VAR ID ID EQUALSVAR number
    (65) declaration -> . VAR ID ID EQUALSVAR STR
    (66) mathExp -> . number
    (67) mathExp -> . number operator number
    (43) number -> . INT
    (44) number -> . FLOAT

    ID              shift and go to state 4
    CASE            shift and go to state 12
    FOR             shift and go to state 19
    IF              shift and go to state 20
    FUNC            shift and go to state 21
    SWITCH          shift and go to state 24
    TYPE            shift and go to state 25
    RETURN          shift and go to state 22
    VAR             shift and go to state 26
    INT             shift and go to state 13
    FLOAT           shift and go to state 28

    repeatLines                    shift and go to state 175
    line                           shift and go to state 3
    stamentFor                     shift and go to state 5
    consulta                       shift and go to state 6
    push                           shift and go to state 7
    funcion                        shift and go to state 8
    array                          shift and go to state 9
    slice                          shift and go to state 10
    mathExpProd                    shift and go to state 11
    switch                         shift and go to state 14
    pila                           shift and go to state 15
    func_declaration               shift and go to state 16
    retorno                        shift and go to state 17
    declaration                    shift and go to state 18
    mathExp                        shift and go to state 23
    number                         shift and go to state 27

state 174

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA . ID RPAREN RCURLY

    ID              shift and go to state 176


state 175

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines . RCURLY

    RCURLY          shift and go to state 177


state 176

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID . RPAREN RCURLY

    RPAREN          shift and go to state 178


state 177

    (36) stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .

    ID              reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    CASE            reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    FOR             reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    IF              reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    FUNC            reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    SWITCH          reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    TYPE            reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    RETURN          reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    VAR             reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    INT             reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    FLOAT           reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    $end            reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)
    RCURLY          reduce using rule 36 (stamentFor -> FOR ID EQUALS INT DOTCOMA ID MINUSTHAN LEN LPAREN ID RPAREN DOTCOMA ID PLUS PLUS LCURLY repeatLines RCURLY .)


state 178

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN . RCURLY

    RCURLY          shift and go to state 179


state 179

    (54) push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .

    ID              reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    CASE            reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    FOR             reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    IF              reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    FUNC            reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    SWITCH          reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    TYPE            reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    RETURN          reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    VAR             reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    INT             reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    FLOAT           reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    $end            reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)
    RCURLY          reduce using rule 54 (push -> FUNC PUSH LPAREN ID STACK COMMA ID ID RPAREN STACK LCURLY RETURN APPEND LPAREN ID COMMA ID RPAREN RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RETURN in state 3 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 27 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 27 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 27 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 27 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 37 resolved as shift
WARNING: reduce/reduce conflict in state 55 resolved using rule (value -> INT)
WARNING: rejected rule (line -> ID EQUALSVAR INT) in state 55
WARNING: Rule (line -> ID EQUALSVAR INT) is never reduced
